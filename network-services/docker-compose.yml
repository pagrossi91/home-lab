networks: 
  nginx_network: 
    name: "nginx_network" 
    driver: bridge 
    ipam:
      config:
        - subnet: ${NGINX_NETWORK_SUBNET}
          gateway: ${NGINX_NETWORK_GATEWAY}

services: 
  duckdns:
    image: lscr.io/linuxserver/duckdns:latest
    container_name: duckdns
    networks:
      - nginx_network
    environment:
      PUID: ${LOCAL_USER}
      PGID: ${LOCAL_USER}
      TZ: ${TZ}
      SUBDOMAINS: ${DUCKDNS}
      TOKEN: ${DUCKDNS_TOKEN}
      LOG_FILE: "false" #optional
    volumes:
      - ./duckdns/config:/config #optional
    restart: unless-stopped

  # wireguard:
  #   image: linuxserver/wireguard
  #   container_name: wireguard
  #   networks:
  #     wg-pihole: 
  #       ipv4_address: 172.30.0.3 # internal Docker address of wireguard
  #       ipv6_address: fdd6:24e8:ea4e::3
  #   environment:
  #     PUID: ${LOCAL_USER}
  #     PGID: ${LOCAL_USER}
  #     TZ: ${TZ}
  #     SERVERURL: ${DUCKDNS} #optional
  #     SERVERPORT: 51820 #optional
  #     PEERS: pgiphone, pgipad, pgmsi, lgiphone, lgipad, lgwork, misc1, misc2 # number, or list, of devices needing to connect to wireguard server
  #     PEERDNS: 172.30.0.2 #optional # internal Docker address of pihole
  #     INTERNAL_SUBNET: 10.13.13.0 #optional, ipv6 needs manual updating of conf files fd1a:d69f:1222::0/64
  #     ALLOWEDIPS: 0.0.0.0/0, ::/0 #optional
  #     PERSISTENTKEEPALIVE_PEERS: all
  #     # LOG_CONFS: true
  #   volumes:
  #     - ./wireguard/wireguard-server/config:/config
  #     - ./wireguard/lib/modules:/lib/modules
  #   ports:
  #     - 51820:51820/udp
  #   cap_add:
  #     - NET_ADMIN
  #     - SYS_MODULE
  #   dns: 
  #     # - 192.168.1.99
  #     - 172.30.0.2 # internal Docker address of pihole 
  #   sysctls:
  #     net.ipv4.conf.all.src_valid_mark: 1
  #     net.ipv4.ip_forward: 1
  #     # net.ipv6.conf.all.forwarding: 1
  #     net.ipv6.conf.all.disable_ipv6: 0 # https://bodhilinux.boards.net/thread/450/wireguard-rtnetlink-answers-permission-denied
  #     net.ipv6.conf.default.disable_ipv6: 0
  #     net.ipv6.conf.lo.disable_ipv6: 0
  #     # net.ipv6.conf.default.forwarding: 1
  #     net.ipv6.conf.all.forwarding: 1
  #     net.ipv6.conf.all.proxy_ndp: 1
  #     # net.ipv6.conf.ens5.accept_ra: 2
  #   restart: unless-stopped
  #   depends_on:
  #     - phiole
  #     - wg-ipv6-helper

  # https://github.com/pi-hole/docker-pi-hole/blob/master/README.md
  pihole:
    container_name: pihole
    image: pihole/pihole:latest
    hostname: pihole-docker
    networks:
      nginx_network:
        ipv4_address: ${PIHOLE_STATIC_IP} # internal Docker address of pihole
        # ipv6_address: fdd6:24e8:ea4e::2
    # dns:
    #   - 127.0.0.1
    #   - 1.1.1.1
    ports: # For DHCP it is recommended to remove these ports and instead add: network_mode: "host" - Disregard this when set up with a USER DEFINED NETWORK (e.g. used in conjunction with WIREGUARD)
      - "53:53/tcp"
      - "53:53/udp"
      # - "67:67/udp" # Necessary when DHCP on its own but not necessary when used in conjunction with dhcp-helper. dhcp-helper is set to listen on UDP port 67 for DHCP requests instead which are then forwarded to Pi-Hole
      - "81:80/tcp"
      # Default HTTPS Port. FTL will generate a self-signed certificate
      - "444:443/tcp"
    environment:
      FTLCONF_webserver_api_password: ${PIHOLE_WEBPASSWORD}
      FTLCONF_dns_upstreams:  ${DNSCRYPTPROXY_STATIC_IP}#5053  # 1.1.1.1;1.0.0.1 #;2606:4700:4700::1111;2606:4700:4700::1001 # Cloudfare DNS; IPv4 and IPv6
      # FTLCONF_dhcp_active: "true" # if used, must add DHCP_START, DHCP_END, and DCHP_ROUTER environment variables
      # FTLCONF_dhcp_start: ${DHCP_START}
      # FTLCONF_dhcp_end: ${DHCP_END}
      # FTLCONF_dhcp_router: ${DHCP_ROUTER_IP}
      # FTLCONF_dhcp_ipv6: "true"
      FTLCONF_dns_listeningMode: all # Necessary for USER DEFINED NETWORK
      TZ: ${TZ}
    volumes: # Volumes store your data between container upgrades
      - './pi-hole/etc-pihole/:/etc/pihole/'
      - './pi-hole/etc-dnsmasq.d/:/etc/dnsmasq.d/'
      # run `touch ./var-log/pihole.log` first unless you like errors (doing this grants the container user "write" permissions to the logs)
      - './pi-hole/var-log/pihole.log:/var/log/pihole.log' # pi-hole logs
    cap_add:
      - NET_ADMIN # Required if you are using Pi-hole as your DHCP server, else not needed
      - SYS_TIME 
      - SYS_NICE
    restart: unless-stopped
    depends_on:
      # - wireguard # force pi-hole to start after wireguard
      # - dhcphelper # force pi-hole to start after dhcphelper
      - dnscrypt-proxy
    labels:
      - "com.centurylinklabs.watchtower.enable=false" # excludes container from watchtower update

  # Runs a DHCP relay container that listens for DHCP discovery requests on the LAN and forwards them to Pihole on Dockerâ€™s internal network. Required with user defined network
  # dhcphelper: 
  #   container_name: dhcp-helper
  #   build: ./dhcp-helper
  #   restart: unless-stopped
  #   network_mode: host # Resides on host network so it can listen for DHCP discovery requests from UDP port 67
  #   command: -s 172.30.0.2 # Forwards to Internal Docker Address of pihole
  #   labels:
  #     - "com.centurylinklabs.watchtower.enable=false" # excludes container from watchtower update
  #   cap_add:
  #     - NET_ADMIN

  # wg-ipv6-helper: # https://github.com/ironhalik/docker-wireguard/issues/1
  #   image: alpine:latest
  #   container_name: wg-ipv6-helper
  #   command: ["ip", "-6", "route", "add", "${SERVER_IPv6}", "via", "fdd6:24e8:ea4e::3"]
  #   network_mode: host
  #   cap_add:
  #     - NET_ADMIN
  #     - SYS_MODULE

  dnscrypt-server:
    image: jedisct1/dnscrypt-server:latest
    container_name: dnscrypt-server
    restart: always
    networks:
      nginx_network:
        ipv4_address: ${DNSCRYPTSERVER_STATIC_IP}
    # command: "init -N ${DOMAIN} -E '${DNSCRYPTSERVER_STATIC_IP}:5443' -A"
    command: "start"
    ports:
        - '5443:5443/udp'
        - '5443:5443/tcp'
    volumes:
      - ./dnscrypt/server/keys:/opt/encrypted-dns/etc/keys
      - ./dnscrypt/server/unbound:/opt/unbound/etc/unbound
    environment:
      TZ: ${TZ}
      PUID: ${LOCAL_USER}
      PGID: ${LOCAL_USER}

  dnscrypt-proxy:
    container_name: dnscrypt-proxy
    image: klutchell/dnscrypt-proxy:latest
    user: "${LOCAL_USER}:${LOCAL_USER}"
    ports:
      - "5053:5053/tcp"
      - "5053:5053/udp"
    networks:
      nginx_network:
        ipv4_address: ${DNSCRYPTPROXY_STATIC_IP}
    environment:
      PUID: ${LOCAL_USER}
      PGID: ${LOCAL_USER}
    volumes:
      - ./dnscrypt/proxy/config:/config
    restart: unless-stopped
    depends_on:
      - duckdns

  watchtower:
    container_name: watchtower
    image: containrrr/watchtower:latest
    hostname: watchtower-docker
    networks:
      - nginx_network
    environment:
      TZ: ${TZ}
      WATCHTOWER_CLEANUP: 'true'
      # send email notification of update
      WATCHTOWER_NOTIFICATIONS: 'email'
      WATCHTOWER_NOTIFICATION_EMAIL_FROM: ${WATCHTOWER_NOTIFICATION_EMAIL_FROM}
      WATCHTOWER_NOTIFICATION_EMAIL_TO: ${WATCHTOWER_NOTIFICATION_EMAIL_TO}
      WATCHTOWER_NOTIFICATION_EMAIL_SERVER: ${WATCHTOWER_NOTIFICATION_EMAIL_SERVER}
      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PORT: ${WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PORT}
      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_USER: ${WATCHTOWER_NOTIFICATION_EMAIL_SERVER_USER}
      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD: ${WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD}
    volumes:
      - '/var/run/docker.sock:/var/run/docker.sock' # this directory tells watchtower what containers are available to update
      # config.json only necessary if using custom docker respository (GitHub, etc). Not currently in use but mounting the drive anyway
      - '../../.docker/config.json:/config.json' # run `touch ../../.docker/config.json` first unless you like errors
    command: --schedule '0 0 3 * * *' # updates daily at 0300
    #command: --interval 30 # updates every 30 seconds (for troubleshooting)
    restart: unless-stopped

  portainer:
    image: portainer/portainer-ce:latest
    container_name: portainer
    networks:
      - nginx_network
    command: -H unix:///var/run/docker.sock
    environment:
      TZ: ${TZ}
    ports:
      - 9000:9000
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./portainer/data:/data
    restart: always

  swag:
    image: lscr.io/linuxserver/swag:latest
    container_name: swag
    networks:
      nginx_network:
        ipv4_address: ${SWAG_STATIC_IP}
    cap_add:
      - NET_ADMIN
    environment:
      PUID: ${LOCAL_USER}
      PGID: ${LOCAL_USER}
      TZ: ${TZ}
      URL: ${DOMAIN}
      VALIDATION: dns
      SUBDOMAINS: wildcard # Certs will cover sub-subdomains of your main subdomain (ie. *.yoursubdomain.duckdns.org)
      CERTPROVIDER: zerossl
      DNSPLUGIN: duckdns
      EMAIL: ${SSL_EMAIL} #optional. Used for ZeroSSL certs. Without it, cert provider defaults to Let's Encrypt. Also used for receiving expiration notices from Let's Encrypt if renewal fails
      ONLY_SUBDOMAINS: false #optional
      STAGING: false #optional
    volumes:
      - ./swag/config:/config
    ports:
      - 443:443
      - 80:80 #optional
    restart: unless-stopped
